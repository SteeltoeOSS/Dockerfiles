--- /dev/null
+++ ./src/main/java/io/steeltoe/docker/springbootadmin/SteeltoeAdminConfiguration.java	2026-01-27 00:00:00.000000000 +0000
@@ -0,0 +1,126 @@
+package io.steeltoe.docker.springbootadmin;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.module.SimpleModule;
+import de.codecentric.boot.admin.server.web.client.InstanceWebClientCustomizer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.springframework.beans.factory.ObjectProvider;
+import org.springframework.context.annotation.Bean;
+import org.springframework.context.annotation.Configuration;
+import org.springframework.core.annotation.Order;
+import org.springframework.http.client.reactive.ClientHttpConnector;
+import org.springframework.http.codec.json.Jackson2JsonDecoder;
+import org.springframework.http.codec.json.Jackson2JsonEncoder;
+import org.springframework.web.reactive.function.client.ExchangeStrategies;
+import org.springframework.web.reactive.function.client.WebClient;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Configuration to make Spring Boot Admin compatible with Steeltoe actuator responses.
+ *
+ * Steeltoe adds a "type":"Steeltoe" property to its actuator index response, which causes
+ * deserialization failures in AOT-compiled Spring Boot Admin. This configuration provides
+ * a custom WebClient with a manual deserializer that only extracts the _links field.
+ *
+ * @see <a href="https://www.graalvm.org/22.3/reference-manual/native-image/metadata/">GraalVM Reflection Metadata</a>
+ */
+@Configuration(proxyBeanMethods = false)
+public class SteeltoeAdminConfiguration {
+
+    private static final Logger log = LoggerFactory.getLogger(SteeltoeAdminConfiguration.class);
+
+    @Bean
+    @Order(-100)
+    public InstanceWebClientCustomizer steeltoeInstanceWebClientCustomizer(
+            ObjectMapper objectMapper,
+            ObjectProvider<ClientHttpConnector> clientHttpConnectorProvider) {
+
+        log.info("Configuring Spring Boot Admin WebClient for Steeltoe compatibility");
+
+        return (builder) -> {
+            try {
+                Class<?> responseClass = Class.forName(
+                    "de.codecentric.boot.admin.server.services.endpoints.QueryIndexEndpointStrategy$Response");
+                Class<?> endpointRefClass = Class.forName(
+                    "de.codecentric.boot.admin.server.services.endpoints.QueryIndexEndpointStrategy$Response$EndpointRef");
+
+                // Copy the base ObjectMapper to preserve other configuration (date formats, etc.)
+                // while adding our custom deserializer for the actuator index response
+                ObjectMapper mapper = objectMapper.copy();
+                SimpleModule module = new SimpleModule("SteeltoeCompatibility");
+                @SuppressWarnings({"unchecked", "rawtypes"})
+                JsonDeserializer deserializer = new ActuatorIndexResponseDeserializer(responseClass, endpointRefClass);
+                module.addDeserializer((Class) responseClass, deserializer);
+                mapper.registerModule(module);
+
+                ExchangeStrategies strategies = ExchangeStrategies.builder()
+                    .codecs(configurer -> {
+                        configurer.defaultCodecs().jackson2JsonDecoder(new Jackson2JsonDecoder(mapper));
+                        configurer.defaultCodecs().jackson2JsonEncoder(new Jackson2JsonEncoder(mapper));
+                    })
+                    .build();
+
+                WebClient.Builder webClientBuilder = WebClient.builder().exchangeStrategies(strategies);
+                clientHttpConnectorProvider.ifAvailable(connector -> {
+                    webClientBuilder.clientConnector(connector);
+                    log.info("Using custom ClientHttpConnector for SSL trust");
+                });
+
+                builder.webClient(webClientBuilder);
+                log.info("Steeltoe-compatible WebClient configuration complete");
+
+            } catch (ClassNotFoundException e) {
+                log.error("Failed to load SBA Response class: {}", e.getMessage());
+            }
+        };
+    }
+
+    @SuppressWarnings("rawtypes")
+    public static class ActuatorIndexResponseDeserializer extends JsonDeserializer {
+        private static final Logger log = LoggerFactory.getLogger(ActuatorIndexResponseDeserializer.class);
+        private final Class<?> responseClass;
+        private final Class<?> endpointRefClass;
+
+        public ActuatorIndexResponseDeserializer(Class<?> responseClass, Class<?> endpointRefClass) {
+            this.responseClass = responseClass;
+            this.endpointRefClass = endpointRefClass;
+        }
+
+        @Override
+        public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException {
+            JsonNode node = p.getCodec().readTree(p);
+            try {
+                Object response = responseClass.getDeclaredConstructor().newInstance();
+                Map<Object, Object> links = new HashMap<>();
+                if (node.has("_links")) {
+                    node.get("_links").fields().forEachRemaining(entry -> {
+                        try {
+                            JsonNode linkNode = entry.getValue();
+                            String href = linkNode.has("href") ? linkNode.get("href").asText() : null;
+                            boolean templated = linkNode.has("templated") && linkNode.get("templated").asBoolean();
+                            java.lang.reflect.Constructor<?> ctor = endpointRefClass.getDeclaredConstructor(String.class, boolean.class);
+                            ctor.setAccessible(true);
+                            Object ref = ctor.newInstance(href, templated);
+                            links.put(entry.getKey(), ref);
+                        } catch (Exception e) {
+                            log.warn("Failed to parse link '{}': {}", entry.getKey(), e.getMessage());
+                        }
+                    });
+                }
+                responseClass.getMethod("setLinks", Map.class).invoke(response, links);
+                log.debug("Deserialized {} endpoint links", links.size());
+                return response;
+            } catch (Exception e) {
+                throw new IOException("Failed to deserialize actuator index response", e);
+            }
+        }
+    }
+}
